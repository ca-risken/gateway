package main

import (
	"bytes"
	"fmt"
	"go/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"gopkg.in/yaml.v3"
)

const (
	HeaderTemplate string = `
// Code generated by protoc-gen-service. DO NOT EDIT.
// source: {{ .file_name }}

package main

import (
	"net/http"

	"{{ .import_path }}"
)
`

	MethodTemplate string = `
func (g *gatewayService) {{ .method_first_lower }}{{ .package_capital }}Handler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	req := &{{ .package }}.{{ .input_type }}{}
	if err := bind(req, r); err != nil {
		writeResponse(ctx, w, http.StatusBadRequest, map[string]interface{}{errorJSONKey: err.Error()})
		return
	}
	if err := req.Validate(); err != nil {
		writeResponse(ctx, w, http.StatusBadRequest, map[string]interface{}{errorJSONKey: err.Error()})
		return
	}
	resp, err := g.{{ .package }}Client.{{ .method }}(ctx, req)
	if err != nil {
		writeResponse(ctx, w, http.StatusInternalServerError, map[string]interface{}{errorJSONKey: err.Error()})
		return
	}
	writeResponse(ctx, w, http.StatusOK, map[string]interface{}{successJSONKey: resp})
}
`
)

type Config struct {
	// method names to exclude from generation
	ExcludeMethods []string `yaml:"excludes"`
}

func parseReq(r io.Reader) (*plugin.CodeGeneratorRequest, error) {
	buf, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	var req plugin.CodeGeneratorRequest
	if err = proto.Unmarshal(buf, &req); err != nil {
		return nil, err
	}
	return &req, nil
}

func processReq(req *plugin.CodeGeneratorRequest) (*plugin.CodeGeneratorResponse, error) {
	// init
	headerTmpl, err := template.New("headerTemplate").Parse(HeaderTemplate)
	if err != nil {
		return nil, err
	}
	methodTmpl, err := template.New("methodTemplate").Parse(MethodTemplate)
	if err != nil {
		return nil, err
	}

	var configPath string
	for _, p := range strings.Split(req.GetParameter(), ",") {
		spec := strings.SplitN(p, "=", 2)
		if spec[0] == "configPath" {
			configPath = spec[1]
		}
	}
	excludeMethods, err := parseConfig(configPath)
	if err != nil {
		return nil, err
	}

	// build code
	files := make(map[string]*descriptor.FileDescriptorProto)
	for _, f := range req.ProtoFile {
		files[f.GetName()] = f
	}
	c := cases.Title(language.English)
	var resp plugin.CodeGeneratorResponse
	for _, fname := range req.FileToGenerate {
		f := files[fname]
		split := strings.Split(f.GetOptions().GetGoPackage(), "/")
		packageName := split[len(split)-1]
		data := map[string]string{
			"file_name":   f.GetName(),
			"import_path": f.GetOptions().GetGoPackage(),
		}
		var header bytes.Buffer
		if err = headerTmpl.Execute(&header, data); err != nil {
			return nil, err
		}
		content := header.String()

		for _, s := range f.GetService() {
			for _, m := range s.GetMethod() {
				if excludeMethods[fmt.Sprintf("%s.%s", s.GetName(), m.GetName())] {
					continue
				}
				inputTypeElements := strings.Split(m.GetInputType(), ".")
				inputType := inputTypeElements[len(inputTypeElements)-1]
				var methodFirstLower string
				for i, w := range m.GetName() {
					if i == 0 {
						methodFirstLower = strings.ToLower(string(w))
						continue
					}
					methodFirstLower += string(w)
				}
				data = map[string]string{
					"method":             m.GetName(),
					"method_first_lower": methodFirstLower,
					"package":            packageName,
					"package_capital":    c.String(packageName),
					"input_type":         inputType,
					"service_name":       s.GetName(),
				}
				var b bytes.Buffer
				if err = methodTmpl.Execute(&b, data); err != nil {
					return nil, err
				}
				content += b.String()
			}
		}
		src, err := format.Source([]byte(content))
		if err != nil {
			return nil, err
		}
		fileName := fmt.Sprintf("service_%s_generated.go", packageName)
		resp.File = append(resp.File, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(fileName),
			Content: proto.String(string(src)),
		})
	}
	return &resp, nil
}

func parseConfig(path string) (map[string]bool, error) {
	excludes := make(map[string]bool)
	if path == "" {
		return excludes, nil
	}

	file, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	conf := &Config{}
	err = yaml.Unmarshal(file, conf)
	if err != nil {
		return nil, err
	}
	for _, v := range conf.ExcludeMethods {
		excludes[v] = true
	}
	return excludes, err
}

func emitResp(resp *plugin.CodeGeneratorResponse) error {
	buf, err := proto.Marshal(resp)
	if err != nil {
		return err
	}
	_, err = os.Stdout.Write(buf)
	return err
}

func run() error {
	req, err := parseReq(os.Stdin)
	if err != nil {
		return err
	}

	resp, err := processReq(req)
	if err != nil {
		return err
	}

	return emitResp(resp)
}

func main() {
	if err := run(); err != nil {
		log.Fatalln(err)
	}
}
